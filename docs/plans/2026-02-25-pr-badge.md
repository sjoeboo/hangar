# PR Badge in Session Sidebar — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Show a colored `[#123]` badge in the session sidebar for sessions with an OPEN, MERGED, or CLOSED pull request.

**Architecture:** The `prCache` already fetches and stores PR data (number, state) for worktree sessions. This plan adds two things: new lipgloss styles for the three badge states, and a badge rendered after the existing worktree branch badge in `renderSessionItem()`. No new data fetching is needed.

**Tech Stack:** Go, Bubble Tea (`github.com/charmbracelet/bubbletea`), lipgloss (`github.com/charmbracelet/lipgloss`), `internal/ui` package.

---

### Task 1: Add PR badge styles to styles.go

**Files:**
- Modify: `internal/ui/styles.go`

The badge colors follow the existing PR state convention already used in the preview pane: green=OPEN, purple=MERGED, red=CLOSED. We add three exported `lipgloss.Style` vars so they're available throughout the `ui` package.

**Step 1: Add var declarations**

In `internal/ui/styles.go`, find the `SessionStatusSelStyle` var declaration block (around line 242). Add three new vars immediately after it:

```go
// PR badge styles — colored by state, distinct from session status icons
PRBadgeOpen   lipgloss.Style
PRBadgeMerged lipgloss.Style
PRBadgeClosed lipgloss.Style
```

The block should look like:
```go
SessionStatusSelStyle lipgloss.Style

// PR badge styles — colored by state, distinct from session status icons
PRBadgeOpen   lipgloss.Style
PRBadgeMerged lipgloss.Style
PRBadgeClosed lipgloss.Style
```

**Step 2: Initialize the styles in init()**

In the same file, find the `SessionStatusSelStyle` initialization (around line 493). Add the three initializations immediately after:

```go
PRBadgeOpen   = lipgloss.NewStyle().Foreground(ColorGreen)
PRBadgeMerged = lipgloss.NewStyle().Foreground(ColorPurple)
PRBadgeClosed = lipgloss.NewStyle().Foreground(ColorRed)
```

**Step 3: Run the tests to confirm nothing broke**

```bash
go test ./internal/ui/... -run TestStyles -v
```

Expected: all tests PASS (or no tests match — either is fine, there's no dedicated style test for these).

```bash
go build ./...
```

Expected: build succeeds.

**Step 4: Commit**

```bash
git add internal/ui/styles.go
git commit -m "feat: add PR badge lipgloss styles (open/merged/closed)"
```

---

### Task 2: Render the PR badge in renderSessionItem

**Files:**
- Modify: `internal/ui/home.go:6984-7001`

`renderSessionItem` builds the row string. After the worktree badge block (ending around line 6996), add a new block that reads `prCache` and builds a `prBadge` string. Then append `prBadge` to the row format string.

**Step 1: Add the prBadge block**

Find this comment in `home.go` (around line 6984):
```go
// Worktree branch badge for sessions running in git worktrees
worktreeBadge := ""
```

After the closing `}` of the worktree badge block (line 6996), add:

```go
// PR badge for sessions with an open/merged/closed pull request
prBadge := ""
if inst.IsWorktree() {
    h.prCacheMu.Lock()
    pr, hasPR := h.prCache[inst.ID]
    h.prCacheMu.Unlock()
    if hasPR && pr != nil {
        var badgeStyle lipgloss.Style
        switch pr.State {
        case "OPEN":
            badgeStyle = PRBadgeOpen
        case "MERGED":
            badgeStyle = PRBadgeMerged
        case "CLOSED":
            badgeStyle = PRBadgeClosed
        }
        if selected {
            badgeStyle = SessionStatusSelStyle
        }
        if pr.State == "OPEN" || pr.State == "MERGED" || pr.State == "CLOSED" {
            prBadge = badgeStyle.Render(fmt.Sprintf(" [#%d]", pr.Number))
        }
    }
}
```

**Step 2: Append prBadge to the row format**

Find the row format string (line 7001):
```go
row := fmt.Sprintf("%s%s%s %s %s%s%s%s", baseIndent, selectionPrefix, treeStyle.Render(treeConnector), status, title, tool, yoloBadge, worktreeBadge)
```

Change it to:
```go
row := fmt.Sprintf("%s%s%s %s %s%s%s%s%s", baseIndent, selectionPrefix, treeStyle.Render(treeConnector), status, title, tool, yoloBadge, worktreeBadge, prBadge)
```

(One additional `%s` and `prBadge` argument at the end.)

**Step 3: Build to verify no compile errors**

```bash
go build ./...
```

Expected: build succeeds with no errors.

**Step 4: Commit**

```bash
git add internal/ui/home.go
git commit -m "feat: render PR badge in session sidebar row"
```

---

### Task 3: Add a test for the PR badge

**Files:**
- Modify: `internal/ui/home_test.go`

The existing tests set up a `Home`, populate `home.instances`, and call `home.View()` to check rendered output. We follow the same pattern.

**Step 1: Write the failing test**

Add this test function to `internal/ui/home_test.go`:

```go
func TestSessionRowShowsPRBadge(t *testing.T) {
    home := NewHome()
    home.width = 120
    home.height = 30
    home.initialLoading = false

    // Create a worktree session (IsWorktree() returns true when WorktreePath != "")
    inst := &session.Instance{
        ID:               "pr-test-session",
        Title:            "my-feature",
        Tool:             "claude",
        Status:           session.StatusIdle,
        WorktreePath:     "/repo/.git/worktrees/my-feature",
        WorktreeBranch:   "my-feature",
        WorktreeRepoRoot: "/repo",
    }

    home.instancesMu.Lock()
    home.instances = []*session.Instance{inst}
    home.instanceByID[inst.ID] = inst
    home.instancesMu.Unlock()
    home.groupTree = session.NewGroupTree(home.instances)
    home.rebuildFlatItems()

    // Populate the PR cache as if gh pr view returned an open PR
    home.prCacheMu.Lock()
    home.prCache[inst.ID] = &prCacheEntry{
        Number: 42,
        Title:  "Add my feature",
        State:  "OPEN",
        URL:    "https://github.com/org/repo/pull/42",
    }
    home.prCacheMu.Unlock()

    view := home.View()

    if !strings.Contains(view, "[#42]") {
        t.Errorf("expected session row to contain '[#42]', got:\n%s", view)
    }
}
```

**Step 2: Run the test to verify it fails**

```bash
go test ./internal/ui/... -run TestSessionRowShowsPRBadge -v
```

Expected: FAIL — `[#42]` not found in view (badge not yet rendered).

**Step 3: Confirm the implementation from Task 2 makes it pass**

The implementation was already done in Task 2. Re-run:

```bash
go test ./internal/ui/... -run TestSessionRowShowsPRBadge -v
```

Expected: PASS.

**Step 4: Add tests for MERGED and CLOSED states, and verify DRAFT is absent**

Extend the test file with two more focused tests:

```go
func TestSessionRowPRBadgeStates(t *testing.T) {
    tests := []struct {
        state    string
        prNum    int
        wantBadge string
        wantShown bool
    }{
        {"OPEN",   10, "[#10]", true},
        {"MERGED", 20, "[#20]", true},
        {"CLOSED", 30, "[#30]", true},
        {"DRAFT",  40, "[#40]", false},
    }

    for _, tt := range tests {
        t.Run(tt.state, func(t *testing.T) {
            home := NewHome()
            home.width = 120
            home.height = 30
            home.initialLoading = false

            inst := &session.Instance{
                ID:               "pr-state-test",
                Title:            "my-feature",
                Tool:             "claude",
                Status:           session.StatusIdle,
                WorktreePath:     "/repo/.git/worktrees/my-feature",
                WorktreeBranch:   "my-feature",
                WorktreeRepoRoot: "/repo",
            }

            home.instancesMu.Lock()
            home.instances = []*session.Instance{inst}
            home.instanceByID[inst.ID] = inst
            home.instancesMu.Unlock()
            home.groupTree = session.NewGroupTree(home.instances)
            home.rebuildFlatItems()

            home.prCacheMu.Lock()
            home.prCache[inst.ID] = &prCacheEntry{
                Number: tt.prNum,
                State:  tt.state,
            }
            home.prCacheMu.Unlock()

            view := home.View()
            if tt.wantShown && !strings.Contains(view, tt.wantBadge) {
                t.Errorf("state=%s: expected badge %q in view, not found", tt.state, tt.wantBadge)
            }
            if !tt.wantShown && strings.Contains(view, tt.wantBadge) {
                t.Errorf("state=%s: badge %q should not appear in view", tt.state, tt.wantBadge)
            }
        })
    }
}
```

**Step 5: Run all tests**

```bash
go test ./internal/ui/... -run "TestSessionRowPRBadge" -v
```

Expected: all subtests PASS.

**Step 6: Run the full test suite to catch regressions**

```bash
go test ./... 2>&1 | grep -E "FAIL|ok|---"
```

Expected: only the two known pre-existing failures (`TestNewDialog_WorktreeToggle_ViaKeyPress`, `TestNewDialog_TypingResetsSuggestionNavigation`). Everything else PASS.

**Step 7: Commit**

```bash
git add internal/ui/home_test.go
git commit -m "test: verify PR badge rendered in session sidebar row"
```
